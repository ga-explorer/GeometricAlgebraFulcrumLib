= Geometric Algebra Fulcrum Library (GA-FuL)
:stem: latexmath

== About GA-FuL

Geometric Algebra Fulcrum Library (GA-FuL for short) is a unified generic C# library for Geometric Algebra computations using any kind of scalars (floating point, rational, symbolic, etc.). GA-FuL can be used for prototyping geometric algorithms based on the powerful mathematics of geometric algebra. The GA-FuL code base can be used to perform numeric computations, symbolic manipulations, and optimized code generation.

=== Why The Name *_Geometric Algebra Fulcrum_*?

*Geometric Algebra (GA)* is a powerful mathematical language that unifies many algebraic tools under the same framework of mathematical operations. Such tools include, for example, real vectors, complex numbers, quaternions, octonions, spinors, matrices, among others; along with their algebraic operations. The most important feature of GA is, however, that it unifies the *geometric reasoning* process among many seemingly diverse fields of application domains. Thus, *Geometric Algebra* acts as a *Mathematical Fulcrum* for geometric reasoning across scientific and engineering domains. We can use this *Geometric Algebra Fulcrum* to seamlessly balance the abstract ideal needs of geometric reasoning with the concrete tools of algebraic manipulation under a unifying mathematical framework.

On the other side, there is a need for software tools that act as a pivot point, i.e. a *Fulcrum*, for prototyping and implementing several kinds of computations on GA's multivectors. Commonly required computations include numerical, symbolic, and code generation, among others. Writing and maintaining a separate code base for each kind is highly impractical. *GA-FuL* is intended to play the role of a *Computational Fulcrum* for prototyping algorithms and implementing software based on *Geometric Algebra*.

=== Citation

You can cite GA-FuL using https://www.mdpi.com/2227-7390/12/14/2272[this article]:
[source,]
----
@Article{Eid2024,
  author    = {Eid, Ahmad Hosny and Montoya, Francisco G.},
  journal   = {Mathematics},
  title     = {Developing GA-FuL: A Generic Wide-Purpose Library for Computing with Geometric Algebra},
  year      = {2024},
  issn      = {2227-7390},
  month     = jul,
  number    = {14},
  pages     = {2272},
  volume    = {12},
  doi       = {10.3390/math12142272},
  publisher = {MDPI AG},
}
----

== GA-FuL Core Design

=== Core Design Intentions

The high-level design of GA-FuL targets a specific set of *Core Design Intentions (CDIs)*. The set of CDIs is a direct result of the experience gained during the development of the predecessor system, https://github.com/ga-explorer/GMac[GMac]. An overview of the CDIs is as follows:

* *CDI-1: Abstracting multivector operations from concrete scalar representations.* In practical computational applications, there are diversely useful representations for the mathematical concept of scalars, as classically introduced in https://www.taylorfrancis.com/books/mono/10.1201/9781315136554/abstract-algebra-applications-karlheinz-spindler[abstract algebra]. The most common representation for numerical applications is for real scalars using the https://dl.acm.org/doi/10.1145/103162.103163[IEEE 754 floating-point number format]. For modern https://databookuw.com/[data-driven and machine learning applications], https://www.sciencedirect.com/book/9780128039533/theory-and-computation-of-tensors[multi-dimensional arrays and tensors] are the basic representations for scalar data. Another very useful representation for scalars, used in most *Computer Algebra Systems (CAS)*, is an https://link.springer.com/book/10.1007/978-3-642-55826-9[expression tree] which represents a symbolic scalar expression for mathematical manipulation applications. The foundational requirement for GA-FuL design is to provide a unified generic implementation for storing and manipulating multivectors and performing common GA operations on any kind of useful scalar representation.

* *CDI-2: Reducing memory requirements for sparse multivectors.* One major obstacle in the way of using GA for practical computations is the memory storage requirements imposed by the structure of multivectors. Storing a full multivector in a stem:[n]-dimensional GA requires stem:[2^{n}] scalars, while storing a full stem:[k]-vector requires stem:[\binom{n}{k}] scalars. For the simplest of numerical scalar representations, 32-bit floating point numbers, a single multivector in a 30-dimensional GA requires 8 GBytes of memory, while a full 15-vector one requires nearly 1.16 GBytes of memory; assuming the use of memory arrays to store the scalars. For most practical GA applications, however, there is rarely a need for storing full multivectors or full k-vectors, and only sparse multivectors are sufficient. One feature of GA is to enable the creation of linear models of nonlinear geometric objects by embedding the original space into a higher-dimension GA space. This typically results in multivectors representing geometric objects using a significantly reduced number of scalars, not a full-sized multivector or stem:[k-vector]. For example, a sparse multivector in https://link.springer.com/chapter/10.1007/11499251_24[5-dimensional conformal GA], containing only 5 out of 32 scalars, can represent points, planes, and spheres of 3-dimensional Euclidean space. As such, another important requirement for the GA-FuL design is to provide a set of generic, memory-efficient data structures for storing the scalars of sparse multivectors in high-dimensional GAs.

* *CDI-3: Providing metaprogramming capabilities.* https://www.worldscientific.com/doi/abs/10.1142/S0218194018300014[Generative programming] in general and https://link.springer.com/book/10.1007/978-1-4471-4126-6[metaprogramming] in particular incorporate the process of creating software systems that treat programs as data, enabling the transformation of existing programs or for the generation of new ones. This was the target of the predecessor system https://github.com/ga-explorer/GMac[GMac] for generating https://arxiv.org/abs/1607.04767[optimized computational numerical code] from a https://www.tandfonline.com/doi/full/10.1080/02726343.2020.1811937[series of GA expressions]. This design goal is carried on to GA-FuL, which would enable code generation targeting high-performance platforms such as CUDA, in addition to classical general purpose programming languages such as C\C++, C#, Java, JavaScript, Python, MATLAB scripts, etc.

* *CDI-4: Introducing a layered system design for a wide spectrum of uses.* The complexity imposed by the previous CDIs must be organized and managed through a layered design of the system. Each layer should specialize in one aspect of the system such as storage management, processing, algebraic and geometric abstractions, etc. In addition, a system of such capabilities would have a wide range of users and use cases. Typically, a user would use the system to create a numerical\symbolic prototype for some geometric modeling ideas, and then after some experimentation, would use metaprogramming system capabilities to generate optimized code for the final model targeting a specific programming language or environment. The design of GA-FuL attempts to realize this layered approach to allow users of different backgrounds to select the suitable level of coding they can handle. The coding level ranges from the very high level of coordinate-independent prototyping using abstract GA operations up to a fully controlled low-level direct manipulation of scalars and coordinates for high-performance computing purposes.

* *CDI-5: Providing a unified, generic, and extensible API for several classes of applications.* The final design goal of GA-FuL is to expose the system functionality through a good *Application Programming Interface (API)*. The API should have a unified public interface with uniform conventions to aid usability. Additionally, the API should be generic regarding the kinds of scalars and GAs it can handle, reflecting the capabilities of the underlying system. API extensibility is also important for future development of the system to aid in the addition of more features and widening system usage. Finally, the API should support the development of various classes of applications including, but not limited to, numerical prototyping computations, symbolic mathematical manipulations, signal processing, visualization, and metaprogramming.

=== Data-Oriented Programming (DOP)

During the initial design of GA-FuL, satisfying the set of CDIs using traditional *Object-Oriented Programming (OOP)* was found to be non-practical. This is mainly due to the tendency of classical OOP practices to increase the code-base complexity of large systems such as GA-FuL. In this context, complexity specifically means the deep coupling of data and behavior code typically imposed by classical OOP principles, especially encapsulation and inheritance. This typically results in complicated relations between system classes and complex inheritance hierarchies, leading to difficulties in understanding the design of large systems. If not properly mitigated, this can eventually result in reduced code understanding and difficulty in system maintenance and extensibility.

The solution found to be most useful was to use a newly emerging software design paradigm that while being compatible with OOP, also tends to produce a more readable, maintainable, and extensible code-base. The use of https://www.manning.com/books/data-oriented-programming[*Data-Oriented Programming (DOP)*] principles, as the highest-level design paradigm, proved to be highly beneficial to many aspects of GA-FuL system design. The https://blog.klipse.tech/dop/2022/06/22/principles-of-dop.html[four core principles of DOP] are follow:

* *DOP-1: Separating behavior code from data.* This is a design tenet that advocates for a distinct division between behavior code and data. Following this DOP principle in OOP entails grouping the behavior code into methods for a static class. In GA-FuL, *DOP-1* is implemented using thin wrapper classes around generic data structures holding the actual data. https://www.oreilly.com/library/view/c-12-and/9781837635870/[Extension methods] in static utility classes operate on the thin-wrapper classes to perform the desired behaviors. 

* *DOP-2: Representing data with generic data structures.* DOP is not dogmatic about the programming constructs used to employ and organize the code. Arrays\lists and dictionaries\maps are the two most widely used generic data structures in prac- tice. However, one can also utilize other general data structures, such queues, trees, and sets. As for *DOP-2* in GA-FuL, sparse algebraic objects, such as stem:[k]-vectors and multivectors, are stored in dictionaries, while dense algebraic objects, such as matrices and multidimensional scalar arrays, are stored in classical array data structures.

* *DOP-3: Making data immutable.* In DOP, due to isolation of representational data structures from behavior code, data mutation is not permitted. Instead, data modifica- tions are carried out by generating new data structure versions. A variableâ€™s reference can be updated to point to a different version of the data, but the actual value of the data must never change. In GA-FuL, *DOP-3* is accomplished through specialized classes called *composers*. A composer for a multivector, for example, performs a data transformation\construction transaction that, when completed properly, generates a valid dictionary containing valid data values that a multivector code wrapper class and extension methods can query and manipulate later.

* *DOP-4: Separating data representation from data schema.* Now that data and code are decoupled and generic immutable data structures are employed to describe it, the challenge is to articulate the shape of the data. The intended shape in DOP is represented by a data schema that is stored apart from the actual data. The primary advantage of *DOP-4* is that it gives developers the freedom to choose which data elements should have a schema and which ones should not. The *DOP-4* principle is accomplished in GA-FuL through the use of generic interfaces and abstract base classes, where the wrapper classes and extension methods manipulate data with a given generic interface or abstract class regardless of the actual data structure implementing the interface\class at any moment during program execution.

As a specific example of how the DOP principles in GA-FuL are implemented, the interface `IIndexSet` is used as a data schema to represent all kinds of index sets for basis blades (according to *DOP-4*). For representing a GA basis blade stem:[e_{i_1,i_2,...,i_k}] , concrete class implementations of this interface internally use a sorted set of non-negative integers stem:[i_1, i_2, ... , i_k] , completely independent of any specific GA metric. There are specialized immutable classes implementing the `IIndexSet` interface for the empty index set; a single-element index set, a more efficient index set with largest index less than 64 (internally using a 64-bit unsigned integer); a dense index set of arbitrary size (using an array of integers); and a sparse index set of arbitrary size (internally using a hash-set object for storing the indices) (according to *DOP-2*, *DOP-3*). The class `XGaBasisBlade` is a thin wrapper around an `IIndexSet` object with member and extension methods for performing basic operations on basis blades such as the geometric and other bilinear products, the reverse operation, etc (in accordance with *DOP-1*).

Another example is the generic interface `IReadOnlyDictionary<IIndexSet, T>` that is the main data schema (*DOP-4*) for storing a sparse list of (basis blade, scalar value) pairs for all kinds of multivectors in GA-FuL. There is a specialized immutable class (*DOP-2*, *DOP-3*) implementing this interface for zero multivectors, another for storing a single (basis blade, scalar value) pair, and one for an arbitrary sparse list of (basis blade, scalar value) pairs. The internal data of a new multivector can be constructed using the `XGaMultivectorComposer<T>` composer class (*DOP-3*) acting as a construction transaction management class (*DOP-1*). The composer class automatically selects the most efficient concrete data structure class implementing the `IReadOnlyDictionary<IIndexSet, T>` interface to be used as internal storage for the constructed multivector.

